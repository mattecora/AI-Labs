################################################################################
#                                  Homework 5                                  #
#                CS 411 - Artificial Intelligence I - Fall 2019                #
#                           Matteo Corain 650088272                            #
################################################################################

## Requirements ##

- Python3 interpreter (tested on Python 3.7.4, Windows OS)
- psutil package (can be installed using pip)

## How to run ##

- Run script puzzle.py using the Python interpreter:
    > python puzzle.py

- Input the size of the puzzle (length of the side, N for a NxN puzzle):
    > Input puzzle dimension: 4 (15-puzzle)

- Input the initial state as a space-separated integer list:
    > Input initial state: 1 0 2 4 5 7 3 8 9 6 11 12 13 10 14 15

- Input the maximum time limit for unsolvable states (in seconds):
    > Input time limit: 30

- State whether the recursive DLS strategy has to be used (default) or not:
    > Use recursion (Y/n)? Y

- If the initial state is solvable, then results are shown:
    > Moves: ['R', 'D', 'L', 'D', 'D', 'R', 'R']
    > Number of nodes expanded: 313
    > Time taken (seconds): 0.01914
    > Memory used (bytes): 77824

- If the initial state is not solvable, an error message is shown:
    > Solution not found.

## How it works ##

The solution for the assignment is similar to the one proposed for the previous 
homework, the only difference being the implementation of the search algorithm 
(in this case, Iterative Deepening Search is used). This is implemented in the 
solve_ids() method of the Puzzle class, which makes use of two possible versions
of the Depth-Limited Search algorithm:

- solve_dls_rec(), which implements a recursive DLS;
- solve_dls_iter(), which implements an iterative DLS.

The selection between the two version is performed through a boolean flag, set 
to True when the recursive version of the Depth-Limited Search algorithm has to 
be used and to False when the iterative version has to be used. In both cases, 
the solve_ids() method performs the following actions:

- It initializes a number of parameters, such as the depth limit (initially set 
to 0), the number of expanded nodes (0), the start time and the start memory;
- It runs a loop until the time difference with the start time is less then the 
set time limit;
- At each iteration, it runs a DLS (either recursive or iterative), retrieving 
the possibly computed solution and the number of expanded nodes in that run of 
the algorithm;
- Consequently, it updates the total number of expanded nodes and checks if the 
result is effectively such (otherwise False is returned); if that is not the 
case, it increments the depth limit and proceeds to the next iteration.

The recursive version of the DLS algorithm takes as parameters the node to be 
considered (initially, the one corresponding to the initial state), the number 
of expansions so far (initially 0), the depth limit (set to the increasing 
value generated by solve_ids()) and a list of visited states (initially empty). 
It performs the following actions:

- It tests the goal fulfillment through the goal_test() method; in case a goal 
state has been reached, it returns the path to reach it and the associated 
number of expansions;
- It checks whether the depth limit has been reached, in which case it returns 
an invalid path and the associated number of expansions;
- It checks whether the current state has already been reached, in which case 
it returns an invalid path and the associated number of expansions;
- If none of the above conditions applies, it inserts the current node's state 
into the visited list and proceeds to expand it through the expand() method;
- For each possible successor node, it recursively calls itself on that node, 
updating the total number of expansions;
- If the recursive call was able to find a solution, it returns such solution 
together with the associated number of expansions.

The iterative version of the DLS algorithm takes a single parameter, the depth 
limit to be used. It initializes the number of expansions to 0, the frontier 
with the initial node and the array of visited states to an empty list; then, 
it loops until the frontier contains an element. For each iteration:

- It extracts a node from the front of the list and checks whether it is a goal 
state; in this case, it returns the path to reach it and the associated number 
of expansions;
- If the node does not correspond to a goal, it checks whether its state has 
already been visited and whether its depth is not greater than the given limit, 
in which case it insterts the node state into the visited list and expands it, 
inserting the successor nodes at the beginning of the frontier.

The other methods are implemented as in the previous assignment.